#!/bin/bash

Myname="${0##*/}"
Version=2.02

# To do:
# Option running  ~/Contacts/sortcont ?
# Always sort vcf output?
# Or even all output?

:<<'DOC'
= contmgr - list contacts for your terminal iPad, Fritz!Box, hand bag

= Synopsis
contmgr [options] [searchkey]	

== General options
-h,--help	print this help and exit
-H,--Help	show full documentation and exit
-V,--version	print version and exit
-i,--input=FILE	take input from FILE with default extension |.vcf|.
-k,--key=STRING	selection key; selects records containing the
		key in the AIM field
-w,--word	search key must be a complete word

== Format options
-b,--booklet	print booklet
-l,--labels	print address labels
-x,--xml	print xml for FritzBox
-t,--term	print to terminal
-S,--sorter	print only first line of |--term| format
-v,--vcard	print vcards

== Format specific options
b, l and t in parentheses specify relevant formats:
-d,--dark	(t)	set colors for dark background
-N,--nocolor	(t)	do not use color in terminal output
-s,--size=INT	(bl)	set fontsize (default: 11)
-n,--noarea=INT	(bl)	in phone numbers, remove area codes with the value
			INT, possibly prefixed with 0 (zero)
-r,--return	(l)	use returnaddres in labels

= Description
contmgr lists your contacts to standard output. If you provide a search
key, only contacts containing that key are listed. With the |--word| option, 
the search key must occur as a whole word.

The input is a vcard file exported from, for example, Thunderbird or the
iCloud. The name of the vcard file is supposed to be in the environment
variable CONTACTS, unless it is given with the |--input| option.

There are some limitations on the data that are read from that
vcard file. The following table shows the vcard fields that are stored
and the formats (v=vcard, x=xml, t=terminal, b=booklet, l=label)
in which they are reproduced:

Last	 vxtbl N 1
First	 vxtbl N 2
Middle	 vxtb- N 3
Prefix	 v---- N 4
Suffix	 v---- N 5
Nick	 vxtb- NICKNAME
Disp	 ----- FN (unused, reconstructed from above entries)
Org	 vxtb- ORG
Url	 v-t-- URL
Bday	 v-t-- BDAY
Hmail	 vxt-- EMAIL;TYPE=HOME
Wmail	 vxt-- EMAIL;TYPE=WORK
Hstreet	 v-tbl ADR;TYPE=HOME 3
Hcity	 v-tbl ADR;TYPE=HOME 4
Hstate	 v-tbl ADR;TYPE=HOME 5
Hzip	 v-tbl ADR;TYPE=HOME 6
Hcntry	 v-tbl ADR;TYPE=HOME 7
Wstreet	 v-t-- ADR;TYPE=WORK 3
Wcity	 v-t-- ADR;TYPE=WORK 4
Wstate	 v-t-- ADR;TYPE=WORK 5
Wzip	 v-t-- ADR;TYPE=WORK 6
Wcntry	 v-t-- ADR;TYPE=WORK 7
Aim	 v-t-- X-AIM
Hphone	 vxt-- TEL;TYPE=HOME
Wphone	 vxt-- TEL;TYPE=WORK
Mphone	 vxt-- TEL;TYPE=CELL
Note	 v-tb- NOTE

= Author
[Wybo Dekker](wybo@dekkerdocumenten.nl)

= Copyright
Released under the [GNU General Public License](www.gnu.org/copyleft/gpl.html)
DOC

    die() { local i; for i; do echo -e "$Myname: $Red$i$Nor"; done 1>&2; exit 1; }
   Warn() { local i; for i; do echo -e "$Myname: $Mag$i$Nor"; done 1>&2; }
helpsrt() { sed -n '/^= Synopsis/,/^= /p' "$0"|sed '1d;$d'; exit; }
helpall() { sed -n "/^:<<'DOC'$/,/^DOC/p" "$0"|sed '1d;$d'|
            less -P"$Myname-${Version/./·} (press h for help, q to quit)";exit; }

:<<'DOC' #----------------------------------------------------------------------
= handle_options
synopsis:	 handle_options "$@"
description:	handle the options.
globals used:	 Myname Version AreaCodes
globals  set:	 args noarea grepopt format return size size2 input keep
		 mycountry key
returns:	the number of remaining arguments
DOC
#-------------------------------------------------------------------------------
handle_options() {
   local options
   if ! options=$(getopt \
      -n "$Myname" \
      -o HIbdf:hi:Kk:ln:r:s:StvwNVx \
      -l Help,booklet,dark,fontsize:,help,input:,keep,key:,labels,noarea:,nocolor,return:,size:,sorter,term,vcard,version,word,xml \
      -- "$@"
   ); then exit 1; fi
   eval set -- "$options"
   
   noarea='' grepopt=-ril format='term' return='' size=11 size2=13
   input="$CONTACTS" keep=false
   mycountry='Nederland' # this is emptied except in vcard format
   
   while [ $# -gt 0 ]; do
      case $1 in
      (-h|--help)    helpsrt
                     ;;
      (-H|--Help)    helpall
                     ;;
      (-V|--version) echo "$Version"
                     exit
                     ;;
      (-i|--input)   input="${2%.vcf}.vcf"
                     shift 2
                     ;;
      (-K|--keep)    keep=true
                     shift
                     ;;
      (-k|--key)     key="$2"
                     shift 2
                     ;;
      (-w|--word)    grepopt=-wirl
                     shift
                     ;;
      (-b|--booklet) format=booklet
                     shift
                     ;;
      (-l|--labels)  format=labels
                     shift
                     ;;
      (-x|--xml)     format=xml
                     shift
                     ;;
      (-t|--term)    format=term
                     shift
                     ;;
      (-S|--sorter)  format=sorter
                     shift
                     ;;
      (-v|--vcard)   format=vcard
                     shift
                     ;;
      (-N|--nocolor) nocolor
                     shift
                     ;;        
      (-d|--dark)    dark
                     shift
                     ;;
      (-s|--size)    size=$2
                     [[ $size =~ ^[0-9.]+$ ]] ||
                        die "size must be a positive float or integer"
                     size2="$(bc <<<"$size+2")"
                     shift 2
                     ;;
      (-n|--noarea)  noarea=${2#0}
                     [[ "${AreaCodes[*]}" =~ $noarea ]] ||
                        die "Unrecognized value for --noarea option"
                     shift 2
                     ;;
      (-r|--return)  return="${2//,/\\bul }"
                     shift 2
                     ;;
      (-I)	     instscript "$0" ||
   		        die 'the -I option is for developers only'
   		     exit
   		     ;;
      (--)           shift; break;;
      (*)            break;;
      esac
   done
   args=( "$@" )
}

:<<'DOC' #---------------------------------------------------------------------
= light
description:	set colors for light background
DOC
#-------------------------------------------------------------------------------
light () {
   Red='\e[38;5;1m'
   Mag='\e[38;5;5m'
   Nor='\e[0m'
   Yel='\e[38;5;3m'
   Blu='\e[38;5;4m'
}

:<<'DOC' #---------------------------------------------------------------------
= dark
description:	set colors for dark background
DOC
#-------------------------------------------------------------------------------
dark () {
   Red='\e[1;38;5;9m'
   Mag='\e[1;38;5;13m'
   Nor='\e[0m'
   Yel='\e[1;38;5;11m'
   Blu='\e[1;38;5;6m'
}

:<<'DOC' #---------------------------------------------------------------------
= nocolor
description:	set no colors
DOC
#-------------------------------------------------------------------------------
nocolor () {
   Red=''
   Mag=''
   Nor=''
   Yel=''
   Blu=''
}

:<<'DOC' #---------------------------------------------------------------------
= join
synopsis:	 join separator string [string...]
description:	use first arg as separator to print other non-empty args separated with it
		 join '=' a b '' d → a=b=d
DOC
#-------------------------------------------------------------------------------
join() {
   local x='' sep="$1"
   shift
   while [ $# -gt 0 ]; do
      [[ -n $1 ]] && x+="${sep}$1"
      shift
   done
   echo "${x##${sep//\\/\\\\}}"
}

:<<'DOC' #---------------------------------------------------------------------
= age
description:	print age; On March 13, 2019:
		after Bday=2011-03-22
		age prints (7)
DOC
#-------------------------------------------------------------------------------
age () {
   local byear bmonth bday cyear cmonth cday corr
   if [[ -n $Bday  ]]; then
      IFS=- read -r byear bmonth bday <<<"$Bday"
      IFS=- read -r cyear cmonth cday <<<"$(date +%Y-%m-%d)"
      corr=0
      if [[ 1"$cmonth" -lt 1"$bmonth" ]] ||
         [[ 1"$cmonth" -eq 1"$bmonth" && 1"$cday" -lt 1"$bday" ]]
      then
         corr=-1
      fi
      echo "("$((cyear-byear+corr))")"
   fi
 
}

:<<'DOC' #---------------------------------------------------------------------
= city
synopsis:	 city zip city state country
description:	if country is Netherlands, insert space in zip and print "zip city",
		if not, print "city, state, zip"
		city 4158CH Deil '' Nederland → 4158 CH Deil
		city 94595 'Walnut Creek' CA USA → Walnut Creek CA 94595
DOC
#-------------------------------------------------------------------------------
city() {
   [[ -z $2 ]] && return # no city = no address
   if [[ $4 == Nederland ]]; then
      if [[ -n $1 ]]; then
         echo "${1:0:4} ${1:4:2} $2"
      else
         echo "$2"
      fi
   else
      echo "$2 $3$1"
   fi
}

:<<'DOC' #---------------------------------------------------------------------
= fix
synopsis:	 fix phonenumber
description:	insert spaces in phone number; argument is name of the number
		Hphone=0630333955
		 fix Hphone && echo $Hphone → 06 3033 3955
DOC
#-------------------------------------------------------------------------------
fix() {
   local area i n p
   eval "p=\$$1"
   case $p in
   ('') eval "$1=''"
        ;;
    (*) for i in "${AreaCodes[@]}"; do
           if [[ $p =~ ^0$i(.*) ]]; then
              area="0$i " n=${BASH_REMATCH[1]}
              [[ $area == "0$noarea " ]] && area=''
              case ${#n} in
              (4)    v="$n";;
              (6|9)  v="${n:0:3} ${n:3:3} ${n:6:3}";;
              (7)    v="${n:0:3} ${n:3:4}";;
              (8|10) v="${n:0:4} ${n:4:4} ${n:8:2}";;
              (*)    Warn "Invalid phone number: $area$n"
                     v="$n"
              esac
              eval "$1=\$area\${v% }"
           fi
        done
        ;;
   esac
}

:<<'DOC' #---------------------------------------------------------------------
= texescape
synopsis:	 texescape varname
description:	escape #, _, %, & in the variable named in the argument
		 x='50%'; texescape x; echo $x → 50\%
DOC
#-------------------------------------------------------------------------------
texescape() {
   eval "$1=\${$1//#/\\\\#}
   $1=\${$1//%/\\\\%}
   $1=\${$1//&/\\\\&}
   $1=\${$1//_/\\\\_}"
}

:<<'DOC' #---------------------------------------------------------------------
= displayname
description:	print Last, First (Organization), but clean up if some are empty.
		First=Wybo Last=Dekker Org=DekDoc displayname → Dekker, Wybo (DekDoc)
		First=Wybo Last=Dekker Org=''     displayname → Dekker, Wybo
		First=''   Last=Dekker Org=DekDoc displayname → Dekker (DekDoc)
		First=''   Last=''     Org=DekDoc displayname → DekDoc
DOC
#-------------------------------------------------------------------------------
displayname() {
   dn="$Last${Last:+,}${First:+ }$First${Middle:+ }$Middle${Nick:+ }$Nick${Org:+ (}$Org${Org:+)}"
   [[ $dn =~ ^\ \((.*)\)$ ]] && dn=${BASH_REMATCH[1]}
   echo "${dn:-—no name—}"
}

:<<'DOC' #---------------------------------------------------------------------
= setvar
synopsis:	 setvar varname value vardescription 
description:	set named variable to value, but only if it's empty:
		Example: setvar Hphone +31345652152 'home phone'
DOC
#-------------------------------------------------------------------------------
Hphone='' Mphone='' Wphone='' Hmail='' Wmail='' # satisfy shellcheck
setvar() {
   local current
   eval "current=\$$1"
   if [[ -n $current ]]; then 
      Warn "Skipping $2: only one value for $3 allowed"
   else
      eval "$1=$2"
   fi
}

:<<'DOC' #---------------------------------------------------------------------
= pr_sorter
description:	print only first line of terminal format
DOC
#-------------------------------------------------------------------------------
pr_sorter() {
   printf "%b %b %b %b\n" "$Disp" "$Bday" "$(age)" "$Aim"
}

:<<'DOC' #---------------------------------------------------------------------
= pr_term
description:	print in terminal format
DOC
#-------------------------------------------------------------------------------
pr_term() {
   hc=$(city "$Hzip" "$Hcity" "$Hstate" "$Hcountry")
   wc=$(city "$Wzip" "$Wcity" "$Wstate" "$Wcountry")
   echo -e "$Nor================================================================================"
   printf "$Yel%-40s%-11s%-6s%27s$Nor\n" "$Disp" "$Bday" "$(age)" "$Aim"
   [[ -n "$Hstreet$Wstreet" ]] && printf "%-40s%s\n" "$Hstreet" "$Wstreet"
   [[ -n "$hc$wc" ]] && printf "%-40s%s\n" "$hc" "$wc"
   h="${Hcountry%Nederland}"
   w="${Wcountry%Nederland}"
   [[ -n "$h$w" ]] && printf "%-40s%s\n" "$Hcountry" "$Wcountry"
   fix Hphone
   fix Mphone
   fix Wphone
   [[ -n "$Hphone$Mphone$Wphone" ]] && printf '%-20s%-20s%s\n' "$Hphone" "$Mphone" "$Wphone"
   [[ -n "$Hmail$Wmail" ]] && printf "$Blu%-40s%s\n" "$Hmail" "$Wmail"
   [[ -n $Note ]] && echo -e "${Note%'\n'}"
}

:<<'DOC' #---------------------------------------------------------------------
= pr_startlabels
description:	print preamble for address labels
DOC
#-------------------------------------------------------------------------------
pr_startlabels() { local awa=''
   [[ -n $return ]] && awa='\awa'
   cat <<-EOD
	%%!lualatex
	%%=== labels ===
	\documentclass[a4paper]{memoir}
	\usepackage{fontspec}
	\protrudechars=2
	\adjustspacing=2
	\newfontfeature{Microtype}{protrusion=default;expansion=default}
	\directlua{fonts.protrusions.setups.default.factor=.5}
	\setmainfont[Microtype,
	             Ligatures=TeX,
	             ItalicFont=Fontin-Italic,
	             BoldFont=Fontin-Bold,
	            ]{Fontin-Regular}
	\usepackage{polyglossia}\setmainlanguage{dutch}
	\usepackage{labels}
	\LabelRows=8\LabelCols=3\TopBorder=0mm\BottomBorder=0mm\LeftBorder=7mm\RightBorder=7mm
	\newcommand{\bul}{{\hfill$\bullet$}\hfill}
	\newcommand{\awa}{\begin{minipage}{56mm}
	  \textbf{\tiny $return}\\\\%[-.5ex]
	  \protect\rule[2ex]{56mm}{.2mm}
	  \end{minipage}\\\\[-3ex]
	}
	\def\C{$awa}
	\def\Red#1{}
	\begin{document}
	\fontsize{$size}{$size2}\selectfont
	\begin{labels}
	EOD
}

:<<'DOC' #---------------------------------------------------------------------
= pr_label
description:	print in address label format
DOC
#-------------------------------------------------------------------------------
pr_label() {
   [[ -n $Hstreet ]] || return
   [[ -n $Hzip    ]] || return
   local street="$Hstreet"
   street=${street//#/\\#}
   street=${street//_/\\_}
   local name="$Prefix $First $Last $Middle $Suffix"
   [[ $name == '    ' ]] && name="$Org"
   echo -e "\\C\n\\Red{$Last}$name\n$street"
   city "$Hzip" "$Hcity" "$Hstate" "$Hcountry"
   [[ $Hcountry == Nederland ]] || echo "$Hcountry"
   echo
}

:<<'DOC' #---------------------------------------------------------------------
= pr_startbooklet
description:	print preamble for booklet format
DOC
#-------------------------------------------------------------------------------
pr_startbooklet() {
   local name="${key:-$(basename "${input%.vcf}")}"
   cat <<-EOD
	%%!lualatex
	%%=== phone book ===
	\documentclass{memoir}
	\usepackage{fontspec}
	\protrudechars=2
	\adjustspacing=2
	\newfontfeature{Microtype}{protrusion=default;expansion=default}
	\directlua{fonts.protrusions.setups.default.factor=.5}
	\setmainfont[Microtype,
	             Ligatures=TeX,
	             ItalicFont=MetaBook-Italic,
	             BoldFont=MetaBoldLF-Roman,
	            ]{MetaBook-Roman}
	\usepackage{polyglossia}\setmainlanguage{dutch}
	\usepackage{ctable}
	\usepackage{colortbl}
	\usepackage{longtable}
	\usepackage[noheadfoot,a4paper,margin=10mm,left=18mm,right=18mm]{geometry}
	\pagestyle{empty}
	\newcommand{\kop}{
	  \hline\strut Naam
	  &Postadres
	  &Telefoon\tabularnewline\hline
	}
	\def\EM#1{\makebox[0pt][r]{#1}}
	\def\Red#1{\textbf{\textcolor[HTML]{BB0000}{#1} }}
	\def\Blu#1{\textcolor[HTML]{0000FF}{#1}}
	\def\C#1{}
	\newcolumntype{L}[1]{>{\raggedright}p{#1mm}}
	\newcolumntype{R}[1]{>{\raggedleft}p{#1mm}}
	\setlength{\extrarowheight}{1ex}
	\def\G{\rowcolor[gray]{.8}}
	\begin{document}%\renewcommand{\arraystretch}{.8}
	\fontsize{$size}{$size2}\selectfont
	\begin{longtable}{L{52}L{68}R{36}}
	  \multicolumn{3}{@{}l@{}}{\Large\bfseries Adreslijst $name
	  \hfill\today}\tabularnewline
	  \kop\endfirsthead
	  \kop\endhead
	EOD
}

:<<'DOC' #---------------------------------------------------------------------
= pr_booklet
description:	print in booklet format
DOC
#-------------------------------------------------------------------------------
pr_booklet() {
   ((gray=!gray))
   local G=('\G' '  ') g=${G[$gray]}
   local adr='' name="$Last"
   [[ -z $name ]] && name="$Org"
   texescape name
   texescape Org

   adr="$(join "\\\\" \
       "$Hstreet" \
       "$(city "$Hzip" "$Hcity" "$Hstate" "$Hcountry")" \
       "${Hcountry%Nederland}" \
   )"
   shopt -u nocasematch
   adr=${adr//\\n/\\\\}
   shopt -s nocasematch
   texescape adr
   fix Hphone
   fix Mphone
   fix Wphone
   Hmail=${Hmail//_/\\_}
   Wmail=${Wmail//_/\\_}
   echo -n "$g\Red{$name} $First"
   [[ -n $Middle ]] && echo -n " $Middle"
   [[ -n $Nick ]] && echo -n " $Nick"
   [[ -n $Org ]] && [[ ! $name == "$Org" ]] && echo -n " ($Org)"
   if [[ -n $Note ]]; then
      local x=()
      texescape Note
      IFS=$'|' read -ra x <<<"${Note//'\n'/|}"
      printf '\\\\\Blu{%s}' "${x[@]}"
   fi
   echo -n "&$adr&"
   echo "\\EM{$(join "}\\\\\\EM{" "$Hphone" "$Mphone" "$Wphone" "$Hmail" "$Wmail")}\\NN"

}

:<<'DOC' #---------------------------------------------------------------------
= pr_startxml
description:	print preamble for FritzBox xml format
DOC
#-------------------------------------------------------------------------------
pr_startxml () {
   cat <<-'EOD'
	<?xml version="1.0" encoding="utf-8"?>
	<phonebooks><phonebook name="Contacts">
	EOD
}

:<<'DOC' #---------------------------------------------------------------------
= pr_xml
description:	print in FritzBox xml format
DOC
#-------------------------------------------------------------------------------
pr_xml () {
   # need at least one telephone number:
   local p=() t=() n=0
   [[ -n $Hphone ]] && { p+=("$Hphone"); t+=(private); ((n++)); }
   [[ -n $Wphone ]] && { p+=("$Wphone"); t+=(business); ((n++)); }
   [[ -n $Mphone ]] && { p+=("$Mphone"); t+=(mobile); ((n++)); }
   if [[ $n -eq 0 ]]; then
      return
   else
   cat <<-EOD
	<contact>
	  <category/>
	  <person>
	    <realName>$Disp</realName>
	  </person>
	EOD
      echo "  <telephony nid=\"$n\">"
      for ((i=0;i<n;i++)); do
         echo "    <number type=\"${t[$i]}\" id=\"$i\">${p[$i]}</number>"
      done
   fi
   echo "  </telephony>"
   p=() t=() n=0
   [[ -n $Hmail ]] && { p+=("$Hmail"); t+=(private); ((n++)); }
   [[ -n $Wmail ]] && { p+=("$Wmail"); t+=(business); ((n++)); }
   if [[ $n -gt 0 ]]; then
      echo "  <services nid=\"$n\">"
      for ((i=0;i<n;i++)); do
         echo "    <email classifier=\"${t[$i]}\" id=\"$i\">${p[$i]}</email>"
      done
      echo "  </services>"
   fi
   echo '</contact>'
}

:<<'DOC' #---------------------------------------------------------------------
= pr_vcard
description:	print vcard
DOC
#-------------------------------------------------------------------------------
pr_vcard () {
   local h w i
   echo -e "BEGIN:VCARD\nVERSION:3.0"
   h="ADR;TYPE=HOME:;;$Hstreet;$Hcity;$Hstate;${Hzip// /};$Hcountry"
   w="ADR;TYPE=WORK:;;$Wstreet;$Wcity;$Wstate;${Wzip// /};$Wcountry"
   for i in "$h" "$w"; do
      if [[ ! $i =~ \;\;\;\;\;\;$ ]]; then
         [[ $i =~ \;$ ]] && i+="$mycountry"
         echo "$i"
      fi
   done
   [[ -n $Bday  ]] && echo "BDAY:$Bday"
   [[ -n $Hmail ]] && printf "EMAIL;TYPE=HOME:%s\n" "$Hmail"
   [[ -n $Wmail ]] && printf "EMAIL;TYPE=WORK:%s\n" "$Wmail"
   echo "FN:$Disp"
   echo "N:$Last;$First;$Middle;$Prefix;$Suffix"
   [[ -n $Nick ]] && echo "NICKNAME:${Nick:1:-1}"
   [[ -n $Note ]] && echo "NOTE:$Note"
   [[ -n $Org ]] && echo "ORG:$Org"
   set -- HOME CELL WORK
   for i in "$Hphone" "$Mphone" "$Wphone"; do
      [[ -n $i ]] || continue
      case $i in
        (0[89]00*) ;;
             (00*) i=+${i#00};;
              (0*) i=+31${i#0};;
              (+*) ;;
               (*) Warn "wrong phone number $i"
      esac
      tel="TEL;TYPE=$1:$i"
      [[ $tel =~ \:$ ]] || echo "$tel"
      shift
   done
   [[ -n $Url ]] && echo "URL:$Url"
   [[ -n $Aim ]] && echo "IMPP;X-SERVICE-TYPE=AIM:aim:$Aim"
   echo -e 'END:VCARD\n'
}

:<<'DOC' #---------------------------------------------------------------------
= filltype
description:	set type to the first argument for which the corresponding
		variable is empty
		note:
		made this, because thunderbird exports home address without
		type=HOME if it's the first address, and the work address
		without type=WORK if it's the second address. iCloud exports
		with both type indications.
		thus, in the absence of type indicators
		the first two addresses are home and work
		the first two emails are home and work
		the first three phonenrs are home, cell and work
DOC
#-------------------------------------------------------------------------------
filltype() {
   until [[ $# -eq 0 ]] || [[ -n $type  ]]; do
      eval "test -z \$$1 && type=${1:1}; shift"
   done
}

AreaCodes=(
   6 10 13 15 20 23 24 26 30 33 35 36 38 40 43 45 46 50 53 55 58 70 71 72
   73 74 75 76 77 78 79 85 87 88 101 111 113 114 115 117 118 161 162 164
   165 166 167 168 172 174 180 181 182 183 184 186 187 222 223 224 226 227
   228 229 251 252 255 294 297 299 313 314 315 316 317 318 320 321 341 342
   343 344 345 346 347 348 411 412 413 416 418 475 478 481 485 486 487 488
   492 493 495 497 499 511 512 513 514 515 516 517 518 519 521 522 523 524
   525 527 528 529 541 543 544 545 546 547 548 561 562 566 570 571 572 573
   575 577 578 591 592 593 594 595 596 597 598 599 800 900 032 033 034 039
   044 049 061 062 064 0599 01
)

light # start with colors for a light background

handle_options "$@"
set -- "${args[@]}"

searchkey="$1"
shopt -s nocasematch

input="$(eval realpath "$input")" # eval allows use of ~
[[ -n $input ]] || die "environment var CONTACTS was empty and --input option not used"
[[ -e $input ]] || die "input file $input not found"
tmp="$(mktemp -dt "$Myname".XXXXXXXXXX)"
if $keep; then
   echo "Running in temp file $tmp"
else
   trap 'cd && rm -rf $tmp; exit;' 0 1 2 15
fi
cd "$tmp" || die "Could not cd to temporary file"

case $format in
(labels)  pr_startlabels;;
(booklet) pr_startbooklet;;
(xml)     pr_startxml;;
(vcard)   ;;
(term)    ;;
esac

# remove \r for unix line endings,
# remove waid=[0-9]* (can occur in phone numbers)
# join lines starting with space (=continuation lines) with previous line
sed 'N;s/;waid=[0-9]\+//;s/\r//g;s/\n //g;P;D' "$input" |
# one file xnnnnn for each vcard:
csplit --suppress-matched -ksz -fx -n5 - /BEGIN:VCARD/ '{*}'

# read each file containing the search key:
find . -type f |
LC_COLLATE=en_US.utf8 sort |
xargs grep $grepopt "$searchkey" |
while read -r file; do
   unset Aim Bday Disp First Hcity Hcountry Hmail Hphone Hstate \
         Hstreet Hzip Last Middle Mphone Nick Note Org Prefix Suffix Url Wcity \
         Wcountry Wmail Wphone Wstate Wstreet Wzip \
         ahome awork phome pcell pwork ehome ework
   # initial expressions for mobile numbers
   mob=(316 3247 3248[4-9] 3249[1-9] 33[67] 393[234] 447[45789] 491[567] 599[479][56] )
   while IFS= read -r line; do
      declare -l type
      [[ $line =~ ^item[0-9]\. ]] && line="${line/${BASH_REMATCH[0]}/}"
      [[ $line =~ ^(version|fn|prodid|rev|impp) ]] && continue
      line=${line//\\,/,}
      # skip type=Fax lines
      [[ $line =~ type=Fax ]] && continue
      # only recognize type Home, Work and Cell
      if [[ $line =~ type=(Home|Work|Cell) ]]; then
         type=${BASH_REMATCH[1]}
      else
         type=''
      fi
      # remove other type, like Pref, Pager...
      while [[ $line =~ \;type=([a-z]+) ]]; do
         line=${line//${BASH_REMATCH[0]}/}
      done
      if [[ $line =~ ^N:(.*)\;(.*)\;(.*)\;(.*)\;(.*) ]]; then
         Last=${BASH_REMATCH[1]}
         First=${BASH_REMATCH[2]}
         Middle=${BASH_REMATCH[3]}
         Prefix=${BASH_REMATCH[4]}
         Suffix=${BASH_REMATCH[5]}
      elif [[ $line =~ ^NICKNAME:(.*) ]]; then
         # shellcheck disable=SC1111
         Nick="“${BASH_REMATCH[1]}”"
      elif [[ $line =~ ^ORG:(.*) ]]; then
         Org=${BASH_REMATCH[1]%;}
      elif [[ $line =~ ^URL*:(.*) ]]; then
         Url=${BASH_REMATCH[1]}
      elif [[ $line =~ ^BDAY.*:(.*) ]]; then
         Bday=${BASH_REMATCH[1]}
      elif [[ $line =~ ^EMAIL:(.*) ]]; then
         m="${BASH_REMATCH[1]}"
         if [[ $m =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$ ]]; then
            filltype ehome ework
            # shellcheck disable=SC2034
            case $type in
            (home) ehome=1
                   setvar Hmail "$m" 'home email'
                   ;;
            (work) ework=1
                   setvar Wmail "$m" 'work email'
                   ;;
              ('') Warn 'Have home and work email addresses, skipping others'
                   ;;
               (*) Warn "Skipping email address $m unrecognized type"
            esac
         else
            Warn "incorrect email address: '$m'"
         fi
      elif [[ $line =~ ^ADR:\;(.*)\;(.*)\;(.*)\;(.*)\;(.*)\;(.*)$ ]]; then
         filltype ahome awork
         # shellcheck disable=SC2034
         case $type in
         (home)
             ahome=1
             Hstreet="${BASH_REMATCH[2]}"
             Hcity="${BASH_REMATCH[3]}"
             Hstate="${BASH_REMATCH[4]}"
             Hzip="${BASH_REMATCH[5]^^}"
             Hzip="${Hzip// /}"
             Hcountry="${BASH_REMATCH[6]/Netherlands/Nederland}"
             ;;
         (work)
             awork=1
             Wstreet="${BASH_REMATCH[2]}"
             Wcity="${BASH_REMATCH[3]}"
             Wstate="${BASH_REMATCH[4]}"
             Wzip="${BASH_REMATCH[5]^^}"
             Wzip="${Wzip// /}"
             Wcountry="${BASH_REMATCH[6]/Netherlands/Nederland}"
             ;;
        ('') Warn 'Have home and work addresses, skipping others'
             ;;
         (*) Warn "Skipping address $line of unrecognized type"
         esac
      elif [[ $line =~ ^X-AIM.*:(.*)$ ]]; then
         Aim=${BASH_REMATCH[1]}
      elif [[ $line =~ ^TEL:(.*) ]]; then
         v="${BASH_REMATCH[1]}"
         if [[ ! $v =~ ^[-()\ 0-9+]+$ ]]; then
            Warn "$(displayname): phone number $v has wrong format"
         fi
         v=${v//[-() ]/}
         for e in "${mob[@]}"; do
            [[ $v =~ ^\+$e ]] && type='cell'
         done
         filltype phome pcell pwork
         v=${v/+31/0}
         v=${v/+/00}
         # shellcheck disable=SC2034
         case $type in
         (home) phome=1 # remember that home phone was set
                setvar Hphone "$v" 'home phone'
                ;;
         (cell) pcell=1 # remember that cell phone was set
                setvar Mphone "$v" 'cell phone'
                ;;
         (work) pwork=1 # remember that work phone was set
                setvar Wphone "$v" 'work phone'
                ;;
           ('') Warn 'Have home, mobile and work phone numbers, skipping others'
                ;;
            (*) Warn "Skipping phone number ($v) of unrecognized type"
         esac
      elif [[ $line =~ ^NOTE:(.*) ]]; then
         Note=${BASH_REMATCH[1]}
      elif [[ $line =~ ^END:VCARD ]]; then
         Disp=$(displayname)
      fi
   done < "$file"

   # If a key was specified, print only if the record has that key.
   # No key specified, just print.
   [[ -n $key ]] && [[ ! $Aim == "$key" ]] && continue
   case $format in
   (labels)  pr_label;;
   (booklet) pr_booklet;;
   (xml)     pr_xml;;
   (term)    pr_term;;
   (sorter)  pr_sorter;;
   (vcard)   pr_vcard;;
   esac
done
case $format in
(labels)  echo '\end{labels}\end{document}';;
(term)    ;;
(sorter)  ;;
(vcard)   ;;
(xml)     echo -e '</phonebook></phonebooks>';;
(booklet) echo '\end{longtable}\end{document}';;
esac
